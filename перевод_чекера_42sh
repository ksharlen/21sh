		руководящие указания

- Вы должны оценивать только то, что находится в репозитории GiT ученика / группы
.

Сначала исправьте обязательную часть. Если и только если это
обязательная часть является ИДЕАЛЬНОЙ (полной и неразрушимой!),
Перейти к модульной части. Имейте в виду, что оболочка
должен быть интуитивно понятным, но чтобы ответы оставались свободными от
реализация определенных деталей. Их эталонная оболочка
не обязательно совпадает с вашим.

Коррекция может быть долгой, если модульная часть хорошо
Поставляется. 42sh не тривиальный проект, не торопитесь
требуется, чтобы тщательно изучить работу ваших сверстников.

- Любой значимый сценарий, облегчающий оценку, предоставленную одним из двух
стороны должны строго проверяться другой стороной
избежать неприятных сюрпризов.

- Если студент-исправитель еще не сделал этого
Для этого студента обязательно прочитать
Вся тема, прежде чем начать эту защиту.

- Используйте флаги, доступные на этой шкале, чтобы сигнализировать
пустой рендеринг, не работает, стандартная ошибка, чит-кейс,
и т.д. В этом случае оценка завершена и итоговая оценка
0 (или -42 в особом случае мошенничества). Тем не менее, за исключением случая
обмана, вам рекомендуется продолжать обмениваться по всему
работа, проделанная (или не сделанная точно) для определения
проблемы, которые привели к этой ситуации и избежать их для
следующий рендеринг

- Возвращаемое значение можно получить с помощью «echo $ {?}».

- Подсказка пользователя будет обозначена символом «$>» во всех тестах шкалы.
Вы должны будете адаптировать свою коррекцию в соответствии с подсказкой оцениваемой группы.

- Части, содержащиеся в заполнителях "{{...}}", обозначают часть
который может варьироваться в зависимости от исправлений.
Вместо этого мы сообщаем вам, что может отображаться.
В результате вы несете ответственность за проверку
отображается в соответствии с темой заполнителя.



		Обязательная часть

Напоминание: если в тот или иной момент программа не реагирует правильно (ошибка шины, ошибка сегмента и т. Д.), Или если вы
обнаружение утечки памяти, защита завершена, и примечание равно 0. Не забудьте использовать соответствующие флаги, когда
считает. Эта инструкция активна от одного конца до другого защиты.



	Авторский файл

Сначала проверьте следующее:

- Есть рендеринг (в репозитории git)
- Действительный файл автора
- Makefile присутствует и хорошо компилирует исполняемый файл 42sh
- Нет стандартной ошибки, Norminette является авторитетным
- Нет обмана (функции не допускаются, студенты
должен быть в состоянии объяснить их код, ...)

Если элемент не соответствует теме, обозначение
остановись там. Вам предлагается продолжить дискуссию
проекта, но масштаб не применяется.



	Утечки памяти

Во время защиты следите за возможными
Утечка памяти в 42sh (с помощью этой команды в другом терминале
пример "while true; do leaks 42sh; sleep 1; clear; done".
Если утечка сообщает об утечке памяти, оценка проекта равна 0.



Предварительные условия для Minishell

Мы оценим предпосылки мини-оболочки.
Если хотя бы один из этих тестов не пройден, весь раздел не пройден
и коррекция прекращается. Выполните следующие тесты:

- выполнить пустую команду «$>». Оболочка не должна ничего делать и
заново отобразить подсказку.

- Выполнить заказ, состоящий только из одного пробела "$>".
Оболочка не должна ничего делать и снова отображать подсказку.

- Выполнить команду, состоящую только из пробелов и
Вкладки. Оболочка не должна ничего делать и снова отображать подсказку.

- Выполнить заказ с несколькими пробелами и вкладками
перед двоичным именем, между каждым аргументом, переданным
двоичный, и после последнего аргумента. Эти пространства и
ненужные таблицы не должны мешать выполнению
порядок.

- Проверить заказ (и / или встроенный) с несуществующими опциями. Убедитесь, что возвращение команды не равно 0.

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> doesnotexist
	{{ Message d'erreur indiquant que la commande n'existe pas/est introuvable }}
	{{ Сообщение об ошибке, указывающее, что заказ не существует / не может быть найден }}

	$> echo ${?}
	{{ Code de retour différent de 0 }}
	{{ Код возврата, отличный от 0 }}

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> /sbin/yubikey_shell
	{{ Message d'erreur indiquant que la commande ne peut être exécuté pour cause de permission insuffisante }}
	{{Сообщение об ошибке, указывающее, что команда не может быть выполнена из-за недостаточных прав доступа}}

	$> echo ${?}
	{{ Code de retour différent de 0 }}
	{{Код возврата, отличный от 0}}

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> /bin/ls
	{{ Sortie de la commande "ls" }}
	{{Выход из команды "ls"}}

	$> echo ${?}
	0

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ls
	{{ Sortie de la commande "ls" }}
	{{Выход из команды "ls"}}

	$> echo ${?}
	0

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> /bin/ls -alF
	{{ Sortie de la commande "ls" avec les arguments "alF" }}
	{{Выход из команды "ls" с аргументами "alF"}}

	$> echo ${?}
	0

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> /bin/ls -l -a -F
	{{ Sortie de la commande "ls" avec les arguments "alF" }}
	{{Выход из команды "ls" с аргументами "alF"}}

	$> echo ${?}
	0

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения.



		Предпосылки 21sh

Мы оценим предпосылки для 21ш.

Если хотя бы один из этих тестов не пройден, весь раздел не пройден, и исправление прекращается. Выполните следующие тесты:

- Убедитесь, что можно перемещаться в командной строке с помощью различных ярлыков и редактировать ее в месте расположения курсора.

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ls > /tmp/ftsh_ls_out /

	$> cat /tmp/ftsh_ls_out
	{{ Sortie de la commande "ls" sur la racine du système }}
	{{Выход из команды "ls" в корне системы}}

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> < /tmp/ftsh_ls_out cat -e >> /tmp/ftsh_ls_out

	$> cat /tmp/ftsh_ls_out
	{{ 2 listing de la racine doivent apparaître et le second doit avoir un $ à la
	fin de chaque ligne }}
	{{2 должен появиться список корня, а второй должен иметь $ в конце каждой строки}}

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> echo 1 >out >&2 2>err
	1

	$> echo 2 >out 2>err

	$> cat err

	$> cat out
	2

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> echo non-standard fd > dup_fd
	$> cat 4 non-standard fd$
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cat <&4
	{{ Message d'erreur indiquant que le descripteur de fichier est invalide }}
	{{Сообщение об ошибке, указывающее, что дескриптор файла недействителен}}

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> echo abc >redir_one_to_all
	$> cat 9 abc$
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cat <&- abc
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ls doesnotexist . 2>&1 >/dev/null
	ls: doesnotexist: No such file or directory

	$> ls doesnotexist . >/dev/null 2>&1
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ls | sort -rn | cat -e
	{{ Contenu du dossier courant, trié, avec un '$' a la fin de chaque ligne }}
	{{Содержимое текущей папки, отсортированное, с '$' в конце каждой строки}}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> base64 < /dev/urandom | head -c 1000 | grep 42 | wc -l | sed -e s/1/Yes/g -e
	s/0/No/g
	{{ Affiche "Yes" ou "No" aléatoirement }}
	{{Случайно отображает "Да" или "Нет"}}

	$> ps a | grep 'base64' | grep -v 'grep'
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ls -1; touch test_file; ls -1
	{{ Affichage des 2 'ls'. Un fichier supplémentaire, "test_file", doit apparaître
	dans la seconde sortie }}
	{{Отображение 2 'ls'. Должен появиться дополнительный файл «test_file» во втором выходе}}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> exit 1 | exit 2 | exit 3; echo "stayin' alive"
	stayin' alive
	$>

	Проверьте, что 42sh не закончился и что приглашение доступны.

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> echo out >&-; echo out2
	{{ Message d'erreur facultatif indiquant qu'il est impossible d'écrire sur stdout }}
	{{Необязательное сообщение об ошибке о невозможности записи в стандартный вывод}}
	out2

	$> echo out >&- | echo out2
	{{ Message d'erreur facultatif indiquant qu'il est impossible d'écrire sur stdout }}
	{{Необязательное сообщение об ошибке о невозможности записи в стандартный вывод}}
	out2

	$> echo out >&- && echo out2
	{{ Message d'erreur facultatif indiquant qu'il est impossible d'écrire sur stdout }}
	{{Необязательное сообщение об ошибке о невозможности записи в стандартный вывод}}

	$> echo out >&- || echo out2
	{{ Message d'erreur facultatif indiquant qu'il est impossible d'écrire sur stdout }}
	{{Необязательное сообщение об ошибке о невозможности записи в стандартный вывод}}
	out2

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cat << END
	heredoc> hello world
	heredoc> and good
	heredoc> morning!
	heredoc> END
	hello world
	and good
	morning!
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cat << EO\
	> F
	heredoc> hi
	heredoc> EOF
	hi

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cat > /tmp/heredoc-append << FIN
	heredoc> abc
	heredoc> FIN

	$> cat -e >> /tmp/heredoc-append << FIN
	heredoc> def
	heredoc> ghi
	heredoc> FIN

	$> cat /tmp/heredoc-append
	abc
	def$
	ghi$
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> (cat < heredoc> abd
	heredoc> abc
	heredoc> abb
	heredoc> EOF
	abb$
	abc$
	abd$
	$>

	Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Например, вы можете проверить перенаправления внутри каналов.



		Встроенные модули

Мы оценим реализацию встроенных функций «exit», «echo», «cd»
и "type".

Если хотя бы один из этих тестов не пройден, весь раздел не пройден, и исправление прекращается. Выполните следующие тесты:

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> echo abc; exit; echo def
	abc
	$> echo ${?}
	0

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> exit 999999999999999999999999999999999999999999

	Проверьте, чтобы поведение 42sh было последовательным и чтобы не было сбоев или произошло неопределенное поведение.

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> exit abc
	{{ Message d'erreur indiquant qu'une valeur numérique est attendue }}
	{{Сообщение об ошибке, указывающее, что ожидается числовое значение}}

	$> echo ${?}
	{{ Code de retour différent de 0 }}
	{{Код возврата, отличный от 0}}

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> exit 1 2 3
	{{ Message d'erreur indiquant un trop grand nombre d'arguments }}
	{{Сообщение об ошибке, указывающее слишком много аргументов}}

	$> echo ${?}
	{{ Code de retour différent de 0 }}
	{{Код возврата, отличный от 0}}

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cd {{ /absolute/path/of/your/choice }}
	$> pwd
	{{ /absolute/path/of/your/choice }}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cd relative/path/of/your/choice
	$> pwd
	{{ relative/path/of/your/choice }}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cd /tmp
	$> /bin/pwd
	/tmp
	$> cd
	$> /bin/pwd
	/Users/{{login_session}}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cd /tmp
	$> pwd
	/tmp
	$> cd /bin
	$> pwd
	/bin
	$> cd -
	$> pwd
	/tmp
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> cd -L /tmp; cd -P ..
	$> pwd
	/private
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> type type ls
	{{ Message indiquant que "type" est un builtin et "ls" une commande avec son path }}
	{{Сообщение, указывающее, что «тип» является встроенным, а «ls» - это команда со cвоим путем}}
	$>

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Например, вы можете протестировать хорошее поведение встроенного «cd», если в среде присутствует переменная «CDPATH».




		Логические операторы

Мы оценим реализацию логических операторов.

Если хотя бы один из этих тестов не пройден, весь раздел не пройден, и исправление прекращается. Выполните следующие тесты:

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ls -l && ls
	{{ Affichage de la commande "ls" 2 fois avec des paramètres differents }}
	{{Отображение команды "ls" 2 раза с разными параметрами}}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ls doesnotexist || echo 'Notice me senpai'
	ls: doesnotexist: No such file or directory
	Notice me senpai
	$> echo ${?}
	0
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> echo 'No error' || echo 'You cant see me'
	No error
	$> echo ${?}
	0
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> false && echo foo || echo bar
	bar
	$> true || echo foo && echo bar
	bar
	$>

	Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения.



		Экологический менеджмент

Мы оценим поддержку внутренних и внешних переменных,
а также реализация встроенных функций «set», «export» и «unset».

Если хотя бы один из этих тестов не пройден, весь раздел не пройден, и исправление прекращается. Выполните следующие тесты:

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> a=hello b=world; b=42 echo ${a}_${b} && echo ${b}
	hello_world
	world
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> directory=/ ls_opt=-atr

	$> ls ${ls_opt} ${directory}
	{{ Sortie de la commande "ls -atr" sur la racine du système }}
	{{Выход из команды "ls -atr" в корне системы}}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> echo ${empty}|cat -e
	$
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> set
	{{ Ensemble des variables internes au shell et d'environnement }}
	{{Набор переменных оболочки и среды}}

	$> set | grep -E '(a|b)='
	a=hello
	b=world
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> env
	{{ Ensemble des variables d'environnement uniquement }}
	{{Набор только переменных среды}}

	$> env | grep -E '(a|b)='
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> export b
	$> printenv b
	world
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ONESHOT= env | grep ONESHOT
	ONESHOT=

	$> env | grep ONESHOT
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> unset a b
	$> env | grep -E '(a|b)='
	$> set | grep -E '(a|b)='
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> unset PATH
	$> PATH=/bin:/usr/bin
	$> mkdir testdir
	$> echo ${?}
	0
	$> ls -1 | grep testdir
	testdir
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> true; echo ${?}; false; echo ${?}
	0
	1

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Например, вы можете проверить параметры встроенного «export».



		Контроль работы

Мы собираемся оценить выполнение контроля работы.

Управление заданиями позволяет контролировать процессы в интерактивном режиме
позволяя размещать команды в фоновом режиме, останавливать их и возобновлять их на переднем плане.

Если хотя бы один из этих тестов не пройден, весь раздел не пройден, и исправление прекращается. Выполните следующие тесты:

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> mkfifo fifo
	$> ls -lR /usr >fifo 2>&1 &
	$> jobs
	{{ Message indiquant que la commande "ls" est en cours d'exécution }}
	{{Сообщение, указывающее, что команда "ls" выполняется}}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> emacs -nw &
	$> emacs -nw &
	$> emacs -nw &
	$> emacs -nw &
	$> emacs -nw &
	$> jobs
	{{ Message indiquant que 5 instances d'emacs sont stoppés en arrière-plan }}
	{{Сообщение о том, что 5 экземпляров Emacs остановлены в фоновом режиме}}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> fg%{{ un des emacs job number }} {{один из номеров задания emacs}}

Процесс Emacs должен вернуться на передний план и быть функциональным.
Повторите столько раз, сколько необходимо, чтобы вернуть все процессы
"Emacs".

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> jobs
	{{ La commande "ls" lancé plus haut doit être la seule restante }}
	{{Запущенная выше команда "ls" должна быть единственной оставшейся}}

	$> cat -e {{ Sortie de la commande "ls". N'attendez pas la fin, coupez l'affichage avec CTRL-C }}
	{{Выход из команды "ls". Не ждите конца, выключите дисплей с помощью CTRL-C}}
	$> jobs
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ls -Rl / 2>&1
	{{ Affichage de la commande "ls". N'attendez pas la fin, appuyez sur CTRL-Z }}
	{{ Message indiquant que la commande est suspendue }}
	{{Отображение команды "ls". Не ждите конца, нажмите CTRL-Z}}
	{{Сообщение о том, что заказ приостановлен}}

	$> jobs
	{{ Message indiquant que la commande est suspendue }}
	{{Сообщение о том, что заказ приостановлен}}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> ps a | grep "ls -Rl /" | grep -v 'grep' | cut -d ' ' -f 2
	{{ PID de la commande "ls" du test précédent }}
	{{PID команды "ls" из предыдущего теста}}

	$> kill {{ PID de la commande "ls" du test précédent }} {{PID команды "ls" из предыдущего теста}}

	$> jobs
	{{ Message indiquant que la commande s'est terminé }}
	{{Сообщение, указывающее, что заказ был выполнен}}
	$>

- Выполните следующую команду и убедитесь, что дисплей соответствует:

	$> jobs
	$> ps a | grep "ls -Rl /" | grep -v 'grep'
	$>



		Cигналы

Мы оценим управление сигналами.

Если хотя бы один из этих тестов не пройден, весь раздел не пройден, и исправление прекращается. Выполните следующие тесты:

- Убедитесь, что оболочка правильно обрабатывает сигналы, излучаемые ее дочерними элементами.

	Для этого вы можете использовать следующую команду:

	$> python -c 'import os, signal;os.kill(os.getpid(), signal.SIGSEGV)'
	{{ Message indiquant le signal reçu }}
	{{Сообщение, указывающее на полученный сигнал}}
	$>

	Замените «SIGSEGV» на сигнал, который вы хотите отправить.
	Проверьте все сигналы!
	Оболочка не должна выходить каким-либо образом, если один из ее дочерних элементов заканчивается сигналом, даже если это «SIGKILL».

- Проверьте, что "CTRL-C" в пустой строке и с помощью команды повторно отображает пустую подсказку.

- выполнить команду:

	$> cat

	Затем нажмите «CTRL-/».
	Команда «cat» должна заканчиваться сообщением, указывающим полученный сигнал и подсказку о доступности.

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения.



		МОДУЛЬНАЯ ЧАСТЬ

Напоминание: вы должны оценивать модульную часть только в том случае, если обязательная часть является ИДЕАЛЬНОЙ. Нет интерес к разработке экзотических функций на оболочке, которая не обеспечивает идеальный базовый функционал! Тесты для cледующих разделов находятся в отдельных файлах. Вы должны выполнить все тесты. Если хотя бы один из этих тестов не пройден, весь раздел не пройден, и вы переходите к
следующий Каждый файл содержит стенограмму сеанса оболочки. Вы должны воспроизвести заказы перечислены в файле и убедитесь, что отображение соответствует ожидаемому. Обратите внимание на подсказки, присутствующие в файлах: - "$>" представляет обычную подсказку, ожидающую команду - ">" представляет неполная команда, ожидающая ввода пользователя ((heredoc, quote, dquote ...)



		ингибиторы

В этом разделе мы оценим наличие и хорошее работа ингибиторов "" "(двойная кавычка)," ’" (одинарная кавычка) и "\" (обратная косая черта).

Подсказка «quote>» указывает, что оболочка ожидает дополнительного ввода для завершения текущей команды.

Тесты для этого раздела можно найти в файле "42sh.quoting.txt".

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения.

Например, вы можете проверить эти команды и убедиться, что
shell реагирует так же, как эталонная оболочка, выбранная группой:

	$> echo foo\
	$> echo "\\'abcd\\'"
	$> echo \'



		Сопоставление с образцом

В этом разделе мы оценим правильное функционирование глобирования («*», «?», «[]», «-», «!»).

Посмотрите в источниках для реализации Globbing,
glob (3) не должен использоваться.

Тесты для этого раздела можно найти в файле "42sh.pattern_matching.txt".

Также сделайте свои собственные тесты!
Например, вы можете проверить, как ведет себя оболочка, если экранировать элемент шаблона (с помощью «\\») или шаблон находится между ингибиторами ("")



		Дополнительное расширение

Проверьте наличие и хорошее функционирование расширений тильды и параметров.

Тесты для этого раздела можно найти в файле "42sh.expansions.txt".

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Существует множество возможных тестов на расширение.
Будьте изобретательны!



		Сгруппированные заказы и вложенные оболочки

Проверьте наличие и правильное функционирование субоболочек и
сгруппированные заказы:

Тесты для этого раздела можно найти в файле "42sh.grouped_commands.txt".

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения.

Также проверьте наличие синтаксических ошибок, таких как:

	$> ()
	$> (echo a|)
	$> (; echo b)
	$> (echo c; ())



		Подмена заказов

Проверьте наличие и правильное функционирование подстановки команд

Тесты для этого раздела можно найти в файле "42sh.command_sub.txt".

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Существует множество возможных тестов для подстановки команд.
Будьте изобретательны!



		Арифметическое расширение

Проверьте наличие и правильное функционирование арифметических расширений

Тесты для этого раздела можно найти в файле "42sh.exp_arithm.txt".

Также проверьте, что расширение выполняется между двойной кавычкой ("" "), а не между одинарной кавычкой (" '"). Проверьте несовместимые значения, такие как " 999999999999999999999999999 + 1 "



		Процесс замещения

Проверьте наличие и правильность функционирования процесса замещения
Тесты для этого раздела можно найти в файле "42sh.process_sub.txt".

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Существует множество возможных тестов для замены процесса.
Будьте изобретательны!



		исторический

Проверьте наличие и правильное функционирование истории.

Тесты для этого раздела можно найти в файле "42sh.history.txt".

Кроме того, выполните следующие тесты:

- Используйте команду "fc -l", чтобы получить историю заказов с их индексами. Затем выполните команду с расширением «!».
Убедитесь, что правильная команда выполнена

- То же, что и выше, но на этот раз с расширением "!-". Убедитесь, что правильная команда выполнена

- Проверьте, что заказы записаны в файл.
Закройте и перезапустите оболочку. Есть ли история старого сессия доступна в новой оболочке?

- выполнить команду:

	$> fc -e vim -1 -10

Убедитесь, что последние 10 команд присутствуют в vim.
Отредактируйте их, если хотите, сохраните и закройте vim.
Команды, присутствующие в vim при закрытии, должны быть выполнены.

- Проверьте, что инкрементальный поиск, с помощью комбинации клавиш CTRL-R
(или другое) работает.

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Есть много возможных тестов относительно истории и ее расширения.
Будьте изобретательны!



		Контекстное динамическое завершение

Проверьте наличие и правильное функционирование динамического завершения.

Если хотя бы один из этих тестов не пройден, весь раздел не пройден, и исправление прекращается. Выполните следующие тесты:

- Проверьте, что завершение команд в «ПУТИ» работает

- То же самое для встроенных

- Проверьте, что завершение является контекстным. Если у вас есть «ls /sbin/» в командной строке и вы нажимаете TAB (или любую другую клавишу, отвечающую за завершение), то должны отображаться только файлы, найденные в каталоге «/sbin».

- Выполните команды:

	$> abc=def
	$> echo ${a

Убедитесь, что завершение предлагает вам переменную "abc".

- Выполните команды:

	$> unset a
	$> echo ${a

Проверьте, что завершение больше не предлагает переменную "abc".

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Есть много возможных тестов для динамического завершения.
Будьте изобретательны!



		Режим редактирования Vi / Readline

Проверьте наличие и правильное функционирование режимов редактирования Vi
и Readline.

Если хотя бы один из этих тестов не пройден, весь раздел не пройден, и исправление прекращается. Выполните следующие тесты:

- Убедитесь, что можно изменить режим редактирования с помощью
команда "set -o vi" или "set -o readline"

- Убедитесь, что все упомянутые ярлыки работают правильно
в теме за 2 режима.

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Есть много возможных тестов для редактирования
линии.
Будьте изобретательны!



		Встроенный псевдоним / unalias

Проверьте наличие и правильное функционирование псевдонимов

Тесты для этого раздела можно найти в файле "42sh.alias.txt".

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Есть много возможных тестов на псевдонимы.
Будьте изобретательны!

Например, вы можете проверить наличие недопустимых псевдонимов, таких как «=», «-» или «/».
Оболочка должна отображать ошибку.



Хеш стол

Проверьте наличие и правильное функционирование хэш-таблицы и
встроенный хеш

Тесты для этого раздела можно найти в файле "42sh.hash.txt".

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Существует множество возможных тестов, касающихся хеш-таблицы и встроенного «хеша».
Будьте изобретательны!



		Встроенный тест

Проверьте наличие и правильное функционирование встроенного «теста»

Тесты для этого раздела можно найти в файле "42sh.test.txt".

В случае внутренней ошибки возвращается код возврата больше 1.
Проверьте это и проверьте наличие сообщения об ошибке.

Например, с помощью команды:

	$> zzz -eq test; echo $?

Не соглашайтесь на коррекционные тесты, делайте свои собственные тесты в качестве дополнения. Существует множество возможных тестов, касающихся хеш-таблицы и встроенного «теста».
Будьте изобретательны!



		БОНУС

		Сценарий оболочки

Проверьте наличие и правильное функционирование сценария оболочки.

		Автозаполнение параметров

Проверьте наличие и правильное функционирование автозаполнения
настройки

		POSIX

Вся оболочка должна быть POSIX для проверки этого бонуса.
Удачи в тестировании на соответствие POSIX :)

		Другие особенности

Если у 42sh есть дополнительные функции, посчитайте их здесь. Вы можете рассчитывать до 5 бонусных функций. Бонусы должны быть на 100% функциональными и не ставить под угрозу стабильность оболочки.

Оцените от 0 (не удалось) до 5 (отлично)



		ЗАКЛЮЧЕНИЕ

Оставьте комментарий к этой оценке























